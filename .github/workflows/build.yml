name: Build and Release

on:
  push:
    tags:
      - 'v*'
    branches:
      - master
  pull_request:
    branches:
      - master
  workflow_dispatch:

permissions:
  contents: write

env:
  PROJECT_NAME: claudewarp
  PYTHON_VERSION: '3.11'

jobs:
  # test:
  #   runs-on: ubuntu-latest
  #   steps:
  #   - uses: actions/checkout@v4
    
  #   - name: Set up Python
  #     uses: actions/setup-python@v4
  #     with:
  #       python-version: ${{ env.PYTHON_VERSION }}
    
  #   - name: Install uv
  #     uses: astral-sh/setup-uv@v4
  #     with:
  #       version: "latest"
    
  #   - name: Install dependencies
  #     run: |
  #       echo "📦 Installing dependencies with uv..."
  #       uv sync --all-groups --all-extras
  #       echo "✅ Dependencies installed successfully"
    
  #   - name: Run tests
  #     run: |
  #       echo "🧪 Running tests..."
  #       uv run pytest tests/ -v --cov=claudewarp --cov-report=xml
  #       echo "✅ Tests completed"
    
  #   - name: Upload coverage
  #     uses: codecov/codecov-action@v3
  #     if: success()
  #     with:
  #       file: ./coverage.xml

  build:
    # needs: test
    strategy:
      matrix:
        include:
          - os: macos-latest
            platform: macos
            arch: arm64
          - os: macos-13
            platform: macos
            arch: x64
          - os: windows-latest
            platform: windows
            arch: x64
          - os: ubuntu-latest
            platform: linux
            arch: x64
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Install uv
      uses: astral-sh/setup-uv@v4
      with:
        version: "latest"
    
    - name: Install system dependencies (macOS)
      if: matrix.platform == 'macos'
      run: |
        echo "🍎 Setting up macOS dependencies..."
        echo "macOS version: $(sw_vers -productVersion)"
        echo "Architecture: $(uname -m)"
        
        # Update Homebrew first
        echo "📦 Updating Homebrew..."
        brew update
        
        # Install create-dmg
        echo "💿 Installing create-dmg..."
        brew install create-dmg
        
        # Verify installation
        echo "✅ Verifying create-dmg installation..."
        which create-dmg
        create-dmg --version || echo "create-dmg version check failed (this is normal for some versions)"
        
        echo "✅ macOS dependencies installed"
    
    - name: Install system dependencies (Windows)
      if: matrix.platform == 'windows'
      shell: pwsh
      run: |
        Write-Output "🪟 Setting up Windows dependencies..."
        # Windows特定依赖（如需要）
        Write-Output "Windows build setup complete"
    
    - name: Install system dependencies (Linux)
      if: matrix.platform == 'linux'
      run: |
        echo "🐧 Setting up Linux dependencies..."
        echo "Ubuntu version: $(lsb_release -d)"
        echo "Architecture: $(uname -m)"
        
        # Update package list
        sudo apt-get update
        
        # Install GUI dependencies for PySide6
        echo "📦 Installing Qt and GUI dependencies..."
        sudo apt-get install -y \
          libqt6gui6 \
          libqt6widgets6 \
          libqt6core6 \
          qt6-base-dev \
          libxcb-xinerama0 \
          libxcb-cursor0 \
          libgl1-mesa-glx \
          libegl1-mesa \
          libfontconfig1 \
          libglib2.0-0 \
          libgtk-3-0 \
          libx11-xcb1 \
          libxkbcommon-x11-0
        
        # Install AppImage tools for packaging
        echo "📦 Installing AppImage tools..."
        wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
        chmod +x appimagetool-x86_64.AppImage
        sudo mv appimagetool-x86_64.AppImage /usr/local/bin/appimagetool
        
        echo "✅ Linux dependencies installed"
    
    - name: Install Python dependencies (macOS)
      if: matrix.platform == 'macos'
      run: |
        echo "📦 Installing Python dependencies with uv..."
        echo "UV version: $(uv --version)"
        echo "Python version: $(uv run python --version)"
        echo "Architecture: $(uname -m)"
        echo "macOS version: $(sw_vers -productVersion)"
        
        # Install dependencies with optimization flags
        uv sync --all-groups --all-extras
        
        # Show installed packages for debugging
        echo "=== Installed packages ==="
        uv run pip list | head -20
        echo "✅ Dependencies installed successfully"
    
    - name: Install Python dependencies (Windows)
      if: matrix.platform == 'windows'
      shell: pwsh
      run: |
        Write-Output "📦 Installing Python dependencies with uv..."
        Write-Output "UV version: $(uv --version)"
        uv sync --all-groups --all-extras
        Write-Output "✅ Dependencies installed successfully"
    
    - name: Install Python dependencies (Linux)
      if: matrix.platform == 'linux'
      run: |
        echo "📦 Installing Python dependencies with uv..."
        echo "UV version: $(uv --version)"
        uv sync --all-groups --all-extras
        echo "✅ Dependencies installed successfully"
    
    - name: Build with PyInstaller (Windows)
      if: matrix.platform == 'windows'
      shell: pwsh
      run: |
        Write-Output "🔨 Building Windows application with PyInstaller..."
        Write-Output "Platform: ${{ matrix.platform }}-${{ matrix.arch }}"
        Write-Output "Python version: $(uv run python --version)"
        
        # Run the Windows build script
        .\scripts\build_pyinstaller.ps1
    
    - name: Build with PyInstaller (macOS)
      if: matrix.platform == 'macos'
      run: |
        echo "🍎 Building macOS application with PyInstaller..."
        echo "Platform: ${{ matrix.platform }}-${{ matrix.arch }}"
        echo "macOS version: $(sw_vers -productVersion)"
        echo "Architecture: $(uname -m)"
        echo "Python version: $(uv run python --version)"
        
        # Set optimization flags for consistent builds
        export PYTHONOPTIMIZE=2
        export PYTHONDONTWRITEBYTECODE=1
        
        # Show system info for debugging size differences
        echo "=== System Information ==="
        echo "Available memory: $(vm_stat | grep 'Pages free' | awk '{print $3}' | sed 's/\.//')"
        echo "Python location: $(which python3)"
        echo "UV Python: $(uv run which python)"
        
        # Run the Unix build script
        bash scripts/build_pyinstaller.sh
    
    - name: Build with PyInstaller (Linux)
      if: matrix.platform == 'linux'
      run: |
        echo "🐧 Building Linux application with PyInstaller..."
        echo "Platform: ${{ matrix.platform }}-${{ matrix.arch }}"
        echo "Ubuntu version: $(lsb_release -d)"
        echo "Architecture: $(uname -m)"
        echo "Python version: $(uv run python --version)"
        
        # Run the Unix build script
        bash scripts/build_pyinstaller.sh
    
    - name: Create DMG (macOS)
      if: matrix.platform == 'macos'
      run: |
        echo "💿 Creating DMG package for macOS..."
        if [ -d "dist/ClaudeWarp.app" ]; then
          echo "✅ ClaudeWarp.app found, creating DMG..."
          
          # Determine DMG name based on version
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            # Extract version from tag (handles both v1.0.0 and 1.0.0 formats)
            VERSION="${GITHUB_REF#refs/tags/}"  # Remove refs/tags/
            VERSION="${VERSION#v}"              # Remove leading v if present
            DMG_NAME="ClaudeWarp-$VERSION-macos-${{ matrix.arch }}.dmg"
          else
            DMG_NAME="ClaudeWarp-macos-${{ matrix.arch }}.dmg"
          fi
          
          # Create a temporary directory for DMG creation
          mkdir -p dmg-temp
          cp -R dist/ClaudeWarp.app dmg-temp/
          
          # Create DMG with create-dmg
          echo "🔧 Attempting to create DMG: $DMG_NAME"
          
          # Try to create DMG, with detailed error reporting
          if create-dmg \
            --volname "ClaudeWarp" \
            --window-pos 200 120 \
            --window-size 600 300 \
            --icon-size 100 \
            --icon "ClaudeWarp.app" 175 120 \
            --hide-extension "ClaudeWarp.app" \
            --app-drop-link 425 120 \
            --no-internet-enable \
            "$DMG_NAME" \
            "dmg-temp"; then
            echo "✅ DMG created successfully"
          else
            DMG_EXIT_CODE=$?
            echo "❌ DMG creation failed with exit code: $DMG_EXIT_CODE"
            
            # Check if DMG file was actually created despite the error
            if [ -f "$DMG_NAME" ]; then
              echo "✅ DMG file exists despite exit code $DMG_EXIT_CODE - this is likely a cleanup issue"
              echo "📏 DMG file size: $(ls -lh "$DMG_NAME" | awk '{print $5}')"
            else
              echo "🔍 Checking create-dmg installation..."
              which create-dmg || echo "create-dmg not found in PATH"
              create-dmg --version || echo "create-dmg version check failed"
              echo "📁 Contents of dmg-temp directory:"
              ls -la dmg-temp/ || echo "dmg-temp directory not accessible"
              echo "⚠️ Will continue with ZIP package only"
            fi
            
            # Try to force unmount any stuck disk images
            echo "🧹 Attempting to clean up any stuck disk images..."
            diskutil list | grep "ClaudeWarp" || echo "No ClaudeWarp disk images found"
            # Force unmount any remaining dmg mounts
            hdiutil detach /Volumes/dmg.* -force 2>/dev/null || echo "No dmg volumes to detach"
          fi
          
          # Clean up temporary directory
          rm -rf dmg-temp
          
          if [ -f "$DMG_NAME" ]; then
            echo "✅ DMG created successfully: $DMG_NAME"
            ls -la "$DMG_NAME"
          else
            echo "⚠️ DMG creation failed, ZIP package will be available"
          fi
        else
          echo "❌ ClaudeWarp.app not found!"
          ls -la dist/
        fi
    
    - name: Create AppImage (Linux)
      if: matrix.platform == 'linux'
      run: |
        echo "📦 Creating AppImage package for Linux..."
        if [ -f "dist/claudewarp" ]; then
          echo "✅ claudewarp executable found, creating AppImage..."
          
          # Determine AppImage name based on version
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            # Extract version from tag (handles both v1.0.0 and 1.0.0 formats)
            VERSION="${GITHUB_REF#refs/tags/}"  # Remove refs/tags/
            VERSION="${VERSION#v}"              # Remove leading v if present
            APPIMAGE_NAME="ClaudeWarp-$VERSION-linux-${{ matrix.arch }}.AppImage"
          else
            APPIMAGE_NAME="ClaudeWarp-linux-${{ matrix.arch }}.AppImage"
          fi
          
          # Create AppDir structure
          mkdir -p ClaudeWarp.AppDir/usr/bin
          mkdir -p ClaudeWarp.AppDir/usr/share/applications
          mkdir -p ClaudeWarp.AppDir/usr/share/icons/hicolor/256x256/apps
          
          # Copy executable
          cp dist/claudewarp ClaudeWarp.AppDir/usr/bin/
          
          # Create desktop file
          cat > ClaudeWarp.AppDir/claudewarp.desktop << EOF
        [Desktop Entry]
        Type=Application
        Name=ClaudeWarp
        Comment=Claude API proxy server manager
        Exec=claudewarp
        Icon=claudewarp
        Categories=Development;Network;
        Terminal=false
        EOF
          
          # Copy desktop file to standard location
          cp ClaudeWarp.AppDir/claudewarp.desktop ClaudeWarp.AppDir/usr/share/applications/
          
          # Create a simple icon (placeholder - replace with actual icon if available)
          if [ -f "claudewarp/gui/resources/icons/claudewarp.png" ]; then
            cp claudewarp/gui/resources/icons/claudewarp.png ClaudeWarp.AppDir/claudewarp.png
            cp claudewarp/gui/resources/icons/claudewarp.png ClaudeWarp.AppDir/usr/share/icons/hicolor/256x256/apps/claudewarp.png
          else
            # Create a simple placeholder icon using ImageMagick if available
            echo "⚠️ No icon found, creating placeholder"
            if command -v convert >/dev/null 2>&1; then
              convert -size 256x256 xc:blue ClaudeWarp.AppDir/claudewarp.png
              cp ClaudeWarp.AppDir/claudewarp.png ClaudeWarp.AppDir/usr/share/icons/hicolor/256x256/apps/claudewarp.png
            else
              # Fallback: create empty files
              touch ClaudeWarp.AppDir/claudewarp.png
              touch ClaudeWarp.AppDir/usr/share/icons/hicolor/256x256/apps/claudewarp.png
            fi
          fi
          
          # Create AppRun script
          cat > ClaudeWarp.AppDir/AppRun << 'EOF'
        #!/bin/bash
        # Change to the directory where the AppImage is located
        HERE="$(dirname "$(readlink -f "${0}")")"
        exec "${HERE}/usr/bin/claudewarp" "$@"
        EOF
          chmod +x ClaudeWarp.AppDir/AppRun
          
          # Create AppImage
          echo "🔧 Creating AppImage: $APPIMAGE_NAME"
          if appimagetool ClaudeWarp.AppDir "$APPIMAGE_NAME"; then
            echo "✅ AppImage created successfully: $APPIMAGE_NAME"
            ls -la "$APPIMAGE_NAME"
          else
            echo "❌ AppImage creation failed, but continuing with ZIP package"
            echo "📁 AppDir contents:"
            find ClaudeWarp.AppDir -type f | head -20
          fi
          
          # Clean up
          rm -rf ClaudeWarp.AppDir
          
        else
          echo "❌ claudewarp executable not found!"
          ls -la dist/
        fi
    
    - name: Create release packages (macOS)
      if: matrix.platform == 'macos'
      run: |
        echo "📦 Creating release packages..."
        
        # macOS packages
        if [ -d "dist/ClaudeWarp.app" ]; then
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            # Extract version from tag (handles both v1.0.0 and 1.0.0 formats)
            VERSION="${GITHUB_REF#refs/tags/}"  # Remove refs/tags/
            VERSION="${VERSION#v}"              # Remove leading v if present
            ZIP_NAME="ClaudeWarp-$VERSION-macos-${{ matrix.arch }}.zip"
          else
            ZIP_NAME="ClaudeWarp-macos-${{ matrix.arch }}.zip"
          fi
          
          # Create ZIP
          cd dist && zip -r "../$ZIP_NAME" ClaudeWarp.app && cd ..
          echo "✅ macOS ZIP package created: $ZIP_NAME"
          
          # List all created packages
          ls -la *.zip *.dmg 2>/dev/null || ls -la *.zip
        else
          echo "❌ ClaudeWarp.app not found!"
        fi
    
    - name: Create release packages (Windows)
      if: matrix.platform == 'windows'
      shell: pwsh
      run: |
        Write-Output "📦 Creating Windows release packages..."
        
        # The PowerShell script already created a ZIP, but we need to rename it for versioning
        if (Test-Path "dist\claudewarp.exe") {
          if ($env:GITHUB_REF -like "refs/tags/*") {
            if ($env:GITHUB_REF -like "refs/tags/v*") {
              $version = $env:GITHUB_REF -replace "refs/tags/v", ""
            } else {
              $version = $env:GITHUB_REF -replace "refs/tags/", ""
            }
            $newZipName = "ClaudeWarp-$version-windows-${{ matrix.arch }}.zip"
          } else {
            $newZipName = "ClaudeWarp-windows-${{ matrix.arch }}.zip"
          }
          
          # Find the ZIP created by the build script
          $buildZip = Get-ChildItem -Name "ClaudeWarp-Windows-*.zip" | Select-Object -First 1
          if ($buildZip) {
            # Rename to standardized format
            Move-Item $buildZip $newZipName
            Write-Output "✅ Windows ZIP package renamed to: $newZipName"
          } else {
            # Fallback: create new ZIP if build script didn't create one
            Compress-Archive -Path "dist\claudewarp.exe" -DestinationPath $newZipName
            Write-Output "✅ Windows ZIP package created: $newZipName"
          }
          Get-ChildItem *.zip
        } else {
          Write-Output "❌ claudewarp.exe not found!"
        }
    
    - name: Create release packages (Linux)
      if: matrix.platform == 'linux'
      run: |
        echo "📦 Creating Linux release packages..."
        
        # Linux packages
        if [ -f "dist/claudewarp" ]; then
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            # Extract version from tag (handles both v1.0.0 and 1.0.0 formats)
            VERSION="${GITHUB_REF#refs/tags/}"  # Remove refs/tags/
            VERSION="${VERSION#v}"              # Remove leading v if present
            ZIP_NAME="ClaudeWarp-$VERSION-linux-${{ matrix.arch }}.zip"
          else
            ZIP_NAME="ClaudeWarp-linux-${{ matrix.arch }}.zip"
          fi
          
          # Create ZIP with executable and documentation
          mkdir -p linux-package
          cp dist/claudewarp linux-package/
          cp README.md linux-package/ 2>/dev/null || echo "README.md not found, skipping..."
          cp LICENSE linux-package/ 2>/dev/null || echo "LICENSE not found, skipping..."
          
          # Create Linux-specific usage file
          cat > linux-package/USAGE.txt << EOF
        ClaudeWarp Linux Application
        
        This is the Linux version of ClaudeWarp GUI application.
        
        Usage:
          ./claudewarp
          
        Features:
          - Manage Claude API proxy servers
          - Add, edit, and delete proxy configurations
          - Switch between different proxies
          - Export settings for Claude Code integration
          - GUI interface with Qt/PySide6
        
        Requirements:
          - Linux with X11 or Wayland
          - Qt6 libraries (usually pre-installed)
          
        For AppImage version, download the .AppImage file instead.
        EOF
          
          # Create ZIP
          cd linux-package && zip -r "../$ZIP_NAME" * && cd ..
          rm -rf linux-package
          echo "✅ Linux ZIP package created: $ZIP_NAME"
          
          # List all created packages
          ls -la *.zip *.AppImage 2>/dev/null || ls -la *.zip
        else
          echo "❌ claudewarp executable not found!"
        fi
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.PROJECT_NAME }}-${{ matrix.platform }}-${{ matrix.arch }}
        path: |
          *.zip
          *.dmg
          *.AppImage
          dist/
        retention-days: 30
    
    - name: Debug - List all files (Windows)
      if: matrix.platform == 'windows'
      shell: pwsh
      run: |
        Write-Output "📋 All files in current directory:"
        Get-ChildItem
        Write-Output "📁 Checking for build artifacts:"
        Get-ChildItem -Recurse -Include "*.zip","*.exe","dist" | Select-Object -First 20
    
    - name: Debug - List all files (macOS)
      if: matrix.platform == 'macos'
      run: |
        echo "📋 All files in current directory:"
        ls -la
        echo "📁 Checking for build artifacts:"
        find . -name "*.zip" -o -name "*.dmg" -o -name "dist" | head -20
    
    - name: Debug - List all files (Linux)
      if: matrix.platform == 'linux'
      run: |
        echo "📋 All files in current directory:"
        ls -la
        echo "📁 Checking for build artifacts:"
        find . -name "*.zip" -o -name "*.AppImage" -o -name "dist" | head -20
    
    - name: Get version (Unix)
      if: startsWith(github.ref, 'refs/tags/') && matrix.platform == 'macos'
      id: version-unix
      run: |
        # Extract version from tag (handles both v1.0.0 and 1.0.0 formats)
        VERSION="${GITHUB_REF#refs/tags/}"  # Remove refs/tags/
        VERSION="${VERSION#v}"              # Remove leading v if present
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "Extracted version: $VERSION"
    
    - name: Get version (Windows)
      if: startsWith(github.ref, 'refs/tags/') && matrix.platform == 'windows'
      id: version-windows
      shell: pwsh
      run: |
        # Extract version from tag (handles both v1.0.0 and 1.0.0 formats)
        $ref = "${{ github.ref }}"
        if ($ref -like "refs/tags/v*") {
          $version = $ref -replace "refs/tags/v", ""
        } else {
          $version = $ref -replace "refs/tags/", ""
        }
        Write-Output "VERSION=$version" >> $env:GITHUB_OUTPUT
        Write-Output "Extracted version: $version"
    
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        name: ClaudeWarp v${{ steps.version-unix.outputs.VERSION || steps.version-windows.outputs.VERSION }}
        body: |
          ## ClaudeWarp v${{ steps.version-unix.outputs.VERSION || steps.version-windows.outputs.VERSION }}
          
          ### 下载
          
          - **macOS Intel**: `ClaudeWarp-${{ steps.version-unix.outputs.VERSION || steps.version-windows.outputs.VERSION }}-macos-x64.zip` 或 `.dmg`
          - **macOS Apple Silicon**: `ClaudeWarp-${{ steps.version-unix.outputs.VERSION || steps.version-windows.outputs.VERSION }}-macos-arm64.zip` 或 `.dmg`
          - **Windows**: `ClaudeWarp-${{ steps.version-unix.outputs.VERSION || steps.version-windows.outputs.VERSION }}-windows-x64.zip`
          - **Linux**: `ClaudeWarp-${{ steps.version-unix.outputs.VERSION || steps.version-windows.outputs.VERSION }}-linux-x64.zip` 或 `.AppImage`
          
          ### 安装说明
          
          #### macOS
          1. 下载 `.dmg` 文件或 `.zip` 压缩包
          2. 如果是 `.dmg`：双击打开，拖拽 ClaudeWarp.app 到应用程序文件夹
          3. 如果是 `.zip`：解压后将 ClaudeWarp.app 移动到应用程序文件夹
          4. 首次运行可能需要在系统偏好设置中允许运行
          
          #### Windows
          1. 下载 `.zip` 压缩包
          2. 解压得到 `claudewarp.exe`
          3. 运行 `claudewarp.exe`
          
          #### Linux
          1. **AppImage (推荐)**：下载 `.AppImage` 文件，添加执行权限后直接运行
             ```bash
             chmod +x ClaudeWarp-*.AppImage
             ./ClaudeWarp-*.AppImage
             ```
          2. **ZIP包**：下载 `.zip` 压缩包，解压后运行 `claudewarp` 可执行文件
             ```bash
             unzip ClaudeWarp-*-linux-x64.zip
             cd linux-package
             ./claudewarp
             ```
          
          ### 变更日志
          
          请查看 [CHANGELOG.md](CHANGELOG.md) 了解详细变更内容。
        files: |
          *.zip
          *.dmg
          *.AppImage
        draft: false
        prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}
        token: ${{ secrets.GITHUB_TOKEN }}

  notify:
    needs: [build]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Build Status
      run: |
        echo "📊 Build Summary:"
        # echo "Test result: ${{ needs.test.result }}"
        echo "Build result: ${{ needs.build.result }}"
        
        if [ "${{ needs.build.result }}" == "success" ]; then
          echo "✅ All builds completed successfully!"
        else
          echo "❌ Build failed!"
          # echo "Test status: ${{ needs.test.result }}"
          echo "Build status: ${{ needs.build.result }}"
          exit 1
        fi